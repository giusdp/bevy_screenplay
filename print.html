<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Bevy Talks Documentation</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="getting-started/index.html"><strong aria-hidden="true">2.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="builder/index.html"><strong aria-hidden="true">3.</strong> Creating Talks with TalkBuilder</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Bevy Talks Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction-to-bevy-talks"><a class="header" href="#introduction-to-bevy-talks">Introduction to Bevy Talks</a></h1>
<blockquote>
<p>[â“˜]
Be aware that <code>bevy_talks</code>'s API is still undergoing revisions (with possibly big architectural changes). Feedback on its ergonomics and developer experience (DX) is highly appreciated.</p>
</blockquote>
<p>This [Bevy][bevy] plugin provides a way to create dialogues and conversations in your game as graphs. </p>
<p>You can imagine a <em>Talk</em> between the player and NPCs as a directed graph where each node is an <em>action</em> that can be performed 
such as saying a line, joining/leaving the conversation, or a choice the player can make.</p>
<p>The most common action is text being displayed on the screen, and a simple <em>Talk</em> is
just a sequence of texts forming a conversation between actors.</p>
<p>You can have multiple entities each with their own <em>Talk</em> graph. Or you can make a VN-like game with one single big dialogue graph in the game.</p>
<blockquote>
<p>[!NOTE]
A more in-depth documentation is being slowly written as an <a href="https://giusdp.github.io/bevy_talks/">mdbook here!</a> Help is appreciated :)</p>
</blockquote>
<h2 id="actions-and-actors"><a class="header" href="#actions-and-actors">Actions and Actors</a></h2>
<p>Talks are made up of actions that are translated into graph nodes. 
Actions can be defined either via the <code>TalkBuilder</code> (where you have more control over the dialogue graph with custom components and events) or with &quot;talk.ron&quot; asset files. With the latter, you are building dialogue nodes by passing <code>Action</code> data:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Action {
    /// The ID of the action.
    id: ActionId,
    /// The kind of action.
    action: NodeKind,
    /// The actors involved in the action.
    actors: Vec&lt;ActorSlug&gt;,
    /// Any choices that the user can make during the action.
    choices: Option&lt;Vec&lt;Choice&gt;&gt;,
    /// The text of the action.
    text: Option&lt;String&gt;,
    /// The ID of the next action to perform.
    next: Option&lt;ActionId&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>It contains several fields that define the kind of action it can be, the relevant actors, text or choices and the next action to perform (where to go in the graph after).</p>
<p>The actors are quite simple right now. It is just the name and an identifier (the slug):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Actor {
    /// The name of the actor.
    name: String,
    /// The unique slug of the actor.
    slug: ActorSlug,
}
<span class="boring">}</span></code></pre></pre>
<p>Having a well defined <em>Talk</em> with actions and actors will result in spawning a graph where all the nodes are entities.
Each action will be an entity &quot;node&quot;, and each actor is also an entity. </p>
<p>All the action nodes will be connected with each other with an aery relationship (called <em>FollowedBy</em>), following the graph structure given by the actions next and id fields, and each action with actors will result in the corresponding entity being connected with the actors entities with another aery relationship (called <em>PerformedBy</em>).</p>
<h2 id="the-parent-talk"><a class="header" href="#the-parent-talk">The Parent Talk</a></h2>
<p>All the node entities in the graph will be a child of a main entity that represents the <em>Talk</em> itself, with the <em>Talk</em> component attached to it.</p>
<p>You can think of this parent Talk entity as it &quot;encapsulates&quot; the graph and you can use it to identify a dialogue graph. You will use it to send events to advance the dialogue.</p>
<h2 id="build-talks-from-talkron-files"><a class="header" href="#build-talks-from-talkron-files">Build Talks from talk.ron files</a></h2>
<p>The above-mentioned ron assets files are used to create <code>TalkData</code> assets. They can be used to build dialogue graphs via bevy <code>Commands</code>. </p>
<p>The files must have the extension: <code>talk.ron</code>. Here's an example:</p>
<pre><code class="language-rust ignore">(
    actors: [
        ( slug: &quot;bob&quot;, name: &quot;Bob&quot; ),
        ( slug: &quot;alice&quot;, name: &quot;Alice&quot; )
    ],
    script: [
        ( id: 1, action: Talk, text: Some(&quot;Bob and Alice enter the room.&quot;), next: Some(2) ),
        ( id: 2, action: Join, actors: [ &quot;bob&quot;, &quot;alice&quot; ], next: Some(3)),
        ( id: 3, actors: [&quot;bob&quot;], text: Some(&quot;Hello, Alice!&quot;), next: Some(4) ), // without the action field, it defaults to Talk
        (
            id: 4,
            choices: Some([
                ( text: &quot;Alice says hello back.&quot;, next: 5 ),
                ( text: &quot;Alice ignores Bob.&quot;, next: 6 ),
            ])
        ),
        ( id: 5, text: Some(&quot;Bob smiles.&quot;), next: Some(7)), // without the actors field, it defaults to an empty vector
        ( id: 6, text: Some(&quot;Bob starts crying.&quot;), next: Some(7) ),
        ( id: 7, text: Some(&quot;The end.&quot;) ) // without the next, it is an end node
    ]
)</code></pre>
<p>The plugin adds an <code>AssetLoader</code> for these ron files, so it's as easy as: </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let handle: Handle&lt;TalkData&gt; = asset_server.load(&quot;simple.talk.ron&quot;);
<span class="boring">}</span></code></pre></pre>
<p>Then you can use <code>Talk::builder()</code> to create a <code>TalkBuilder</code>, which has the <code>fill_with_talk_data</code> method. 
You can retrieve the <code>TalkData</code> from the assets collection <code>talks: Res&lt;Assets&lt;TalkData&gt;&gt;</code>.</p>
<p>With the builder ready, you can use the Commands extension to spawn the dialogue graph in the world:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;
use bevy_talks::prelude::*;

// We stored the previously loaded handle of a TalkData asset in this resource
#[derive(Resource)]
struct TalkAsset {
    handle: Handle&lt;TalkData&gt;,
}

fn spawn(mut commands: Commands, talks: Res&lt;Assets&lt;TalkData&gt;&gt;, talk_asset: Res&lt;TalkAsset&gt;) {
    let talk = talks.get(&amp;talk_asset.handle).unwrap();
    let talk_builder = TalkBuilder::default().fill_with_talk_data(simple_talk);

    // spawn the talk graph
    commands.spawn_talk(talk_builder, ());
}
<span class="boring">}</span></code></pre></pre>
<p>Spawning that talk graph will result in this:</p>
<pre><code class="language-mermaid">graph LR;
    A[Narrator Talks] --&gt; B[Alice,Bob Join];
    B --&gt; C[Bob Talks];
    C --&gt; D[Choice];
    D --&gt; E[Narrator Talks];
    D --&gt; F[Narrator Talks];
    F --&gt; G[Narrator Talks];
    E --&gt; G;
</code></pre>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<p>Besides building dialogue graphs, at some point you have to interact with them. 
After all the nodes are entities with components, so you could just do queries using the special <code>CurrentNode</code> component that keeps track of the current node. Then each node could have a <code>TextNode</code>, <code>JoinNode</code>, <code>LeaveNode</code>, <code>ChoiceNode</code> or your own custom components (added via the builder). </p>
<p>Another way is to use a dialogue graph in an event-driven way. The plugin sends events every time you move to a new node based on the components it has. A node with a <code>TextNode</code> will send a <code>TextNodeEvent</code> event, a node with a <code>ChoiceNode</code> will send a <code>ChoiceEvent</code> event, and so on. You can also add your own node emitting components to customize the behaviour.</p>
<p>For example, to display the text of a <code>TextNode</code> you can simply listen to the <code>TextNodeEvent</code> event:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn print_text(mut text_events: EventReader&lt;TextNodeEvent&gt;) {
    for txt_ev in text_events.read() {
        let mut speaker = &quot;Narrator&quot;;
        println!(&quot;{}&quot;, txt_ev.text);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Note that the actors connected to the node are injected in the event, so you don't need to query them.</p>
<h3 id="request-events"><a class="header" href="#request-events">Request Events</a></h3>
<p>That's the events from a dialogue graph to you. There is also the other direction so you can send requests to the dialogue graph (to advance the dialogue).</p>
<p>To move forward to the next action:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Event to request the next node in a `Talk`.
/// It requires an entity with the `Talk` component you want to update.
#[derive(Event)]
pub struct NextNodeRequest  {
    /// The entity with the `Talk` component you want to update.
    pub talk: Entity,
}
<span class="boring">}</span></code></pre></pre>
<p>To jump to a specific action (used with choices):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// An event to jump to some specific node in a graph. 
/// It requires an entity with the `Talk` component you want to update.
#[derive(Event)]
pub struct ChooseNodeRequest {
    /// The entity with the `Talk` component you want to update.
    pub talk: Entity,
    /// The next entity to go to.
    pub next: Entity,
}
<span class="boring">}</span></code></pre></pre>
<p>There is also an useful event to re-send all the events associated to a node:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Event to request the current node to re-send all its events.
#[derive(Event)]
pub struct RefireNodeRequest {
    /// The entity with the `Talk` component you want to update.
    pub talk: Entity,
}
<span class="boring">}</span></code></pre></pre>
<p>You pass the entity with the <code>Talk</code> component in these events, plus the next node entity in case of the choose event.</p>
<p>Check out the <code>examples</code> folder to see how to use the plugin.</p>
<ul>
<li><a href="examples/simple.rs">simple.rs</a> shows how to use the plugin to create a simple, linear conversation. </li>
<li><a href="examples/choices.rs">choices.rs</a> shows how to use the plugin to create a conversation with choices (jumps in the graph).</li>
<li><a href="examples/full.rs">full.rs</a> shows a Talk where all the action kinds are used.</li>
<li><a href="examples/ingame.rs">ingame.rs</a> shows how to use the plugin with more than one talk you can interact with.</li>
<li><a href="examples/custom_node_event.rs">custom_node_event.rs</a> shows how to add your own event emitting component to create a custom node.</li>
</ul>
<h3 id="roadmap"><a class="header" href="#roadmap">Roadmap</a></h3>
<p>Some nice-to-haves from the top of my head:</p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
More node kinds (got rid of node kinds, now nodes are entities with components)</li>
<li><input disabled="" type="checkbox" checked=""/>
Extensive documentation/manual wiki (added an mdbook, but always in progress...)</li>
<li><input disabled="" type="checkbox" checked=""/>
Extensible Interaction/Trigger system (I mean I'm using events, more decoupled than this is impossible)</li>
<li><input disabled="" type="checkbox"/>
Use the built-in bevy_ecs relations (when one day when we will have them)</li>
<li><input disabled="" type="checkbox"/>
Dialogue UIs </li>
<li><input disabled="" type="checkbox"/>
Graphical editor to create the asset files</li>
<li><input disabled="" type="checkbox"/>
Voice lines/sound support</li>
<li><input disabled="" type="checkbox"/>
Support other asset formats (yarn?)</li>
<li><input disabled="" type="checkbox"/>
More examples</li>
<li><input disabled="" type="checkbox"/>
Localization with <a href="https://projectfluent.org/">Fluent</a></li>
</ul>
<h3 id="bevy-version-support"><a class="header" href="#bevy-version-support">Bevy Version Support</a></h3>
<p>Compatibility of <code>bevy_talks</code> versions:
| <code>bevy_talks</code> | <code>bevy</code> |
| :--                 |  :--   |
| <code>main</code>              | <code>0.12</code>  |
| <code>0.5.0</code>              | <code>0.12</code>  |
| <code>0.4.0</code>              | <code>0.12</code>  |
| <code>0.3.1</code>              | <code>0.12</code>  |
| <code>0.3.0</code>              | <code>0.11</code>  |
| <code>0.2.0</code>              | <code>0.11</code>  |
| <code>0.1.1</code>              | <code>0.11</code>  |
| <code>bevy_main</code>              | <code>main</code>  |</p>
<h2 id="license"><a class="header" href="#license">License</a></h2>
<p>Dual-licensed under either of</p>
<ul>
<li>Apache License, Version 2.0, (<a href="/LICENSE-APACHE">LICENSE-APACHE</a> or https://www.apache.org/licenses/LICENSE-2.0)</li>
<li>MIT license (<a href="/LICENSE-MIT">LICENSE-MIT</a> or https://opensource.org/licenses/MIT)</li>
</ul>
<p>at your option.</p>
<h2 id="contribution"><a class="header" href="#contribution">Contribution</a></h2>
<p>Unless you explicitly state otherwise, any contribution intentionally submitted
for inclusion in the work by you, as defined in the Apache-2.0 license, shall be dual licensed as above, without any
additional terms or conditions.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<p><em>In this tutorial we will nstall Bevy Talks and do a quick overview on how to build and spawn a dialogue in your game.</em></p>
<h2 id="content"><a class="header" href="#content">Content</a></h2>
<!-- toc -->
<h2 id="1-installation"><a class="header" href="#1-installation">1. Installation</a></h2>
<p>This plugin is compatible with Bevy 0.12 and is available on crates.io. To install it, add the following line to your <code>Cargo.toml</code> file:</p>
<pre><code class="language-toml">bevy_talks = &quot;0.5&quot;
</code></pre>
<p>or just run:</p>
<pre><code class="language-bash">cargo add bevy_talks
</code></pre>
<h2 id="2-open-the-editor"><a class="header" href="#2-open-the-editor">2. Open the editor</a></h2>
<p>That we don't have yet... one day... one can dream...</p>
<p>Just go to the next section :( </p>
<h2 id="3-create-a-talk"><a class="header" href="#3-create-a-talk">3. Create a talk</a></h2>
<p>You have two ways to create a dialogue: via code or via a file.</p>
<p>If you want to do it via code and perhaps add custom stuff to your dialogue graphs, checkout the next chapter here: <a href="getting-started/index.html#builder">Creating Talks with TalkBuilder</a>.</p>
<p>Otherwise, let's create a <code>talk.ron</code> file in your <code>assets</code> folder, let's call it <code>hello.talk.ron</code>:</p>
<pre><code class="language-ron">(
  actors: [],
  script: []
)
</code></pre>
<p>These files are made of two parts: the actors and the script. The actors are just a list of names and slugs (the identifier for an actor) and the script if a list of actions that can be performed (talk, choice, join and leave).</p>
<h3 id="31-talking"><a class="header" href="#31-talking">3.1 Talking</a></h3>
<p>Let's add an actor (replace the <code>actors</code> field with this):</p>
<pre><code class="language-ron">actors: [
    ( slug: &quot;bob&quot;, name: &quot;Bob&quot; )
],
</code></pre>
<p>Now let's add a talk action:</p>
<pre><code class="language-ron">script: [
    ( id: 1, action: Talk, text: Some(&quot;Hello!&quot;),  actors: [ &quot;bob&quot; ], )
]
</code></pre>
<p>An action needs to have an <code>id</code> so it can be referenced by other actions. The <code>action</code> field is the type of action, in this case <code>Talk</code>. It is not mandatory, if missing defaults to <code>Talk</code>. 
The <code>text</code> field is the text that will be displayed in the dialogue box and needs to be wrapped in <code>Some</code> when present.
Finally, the <code>actors</code> field is a list of slugs of the actors performing the action. If missing, defaults to an empty list.</p>
<h3 id="32-joining"><a class="header" href="#32-joining">3.2 Joining</a></h3>
<p>We could also add a <code>Join</code> action before Bob starts talking to model the fact that he enters the room:</p>
<pre><code class="language-ron">script: [
    ( id: 1, action: Join, actors: [ &quot;bob&quot; ], next: Some(2) ),
    ( id: 2, action: Talk, text: Some(&quot;Hello!&quot;), actors: [ &quot;bob&quot; ], )
]
</code></pre>
<p>We had to add a <code>next</code> field to the <code>Join</code> action to tell the plugin which action to go to next. If missing, defaults to <code>None</code> and the dialogue will end.</p>
<h3 id="33-leaving"><a class="header" href="#33-leaving">3.3 Leaving</a></h3>
<p>Now let's send Bob away after his line:</p>
<pre><code class="language-ron">script: [
    ( id: 1, action: Join, actors: [ &quot;bob&quot; ], next: Some(2) ),
    ( id: 2, text: Some(&quot;Hello!&quot;), actors: [ &quot;bob&quot; ], next: Some(3)),
    ( id: 3, action: Leave, actors: [ &quot;bob&quot; ] )
]
</code></pre>
<p>Notice we can remove the <code>action</code> field from the <code>Talk</code> action, since it defaults to <code>Talk</code>.</p>
<h3 id="34-choices"><a class="header" href="#34-choices">3.4 Choices</a></h3>
<p>The plugin also supports player choices. This results in branching because the talk continues with the action chosen by the player.</p>
<pre><code class="language-ron">script: [
    ( id: 1, action: Join, actors: [ &quot;bob&quot; ], next: Some(2) ),
    ( id: 2, text: Some(&quot;Hello!&quot;), actors: [ &quot;bob&quot; ], next: Some(3) ),
    ( id: 3, action: Choice, choices: Some([
        (text: &quot;Hi Bob&quot;, next: 5), 
        (text: &quot;I'm Alice's BF.&quot;, next: 4)
    ])),
    ( id: 4, action: Leave, actors: [ &quot;bob&quot; ] ),
    ( id: 5, text: Some(&quot;:)&quot;), actors: [ &quot;bob&quot; ] ),
]
</code></pre>
<p>We added a <code>Choice</code> action with two choices. In each choice the <code>text</code> field is the text that you can display associated with a choice, and the <code>next</code> field is the id of the action to go to next if the player chooses that option.</p>
<p>We also don't really need the <code>action</code> field for the Choice action. If the choice vector is defined, it defaults to <code>Choice</code>.</p>
<p>Notice that we didn't add the <code>next</code> field to the last two actions. Any of the two choices will end the dialogue.</p>
<h3 id="35-the-complete-talk"><a class="header" href="#35-the-complete-talk">3.5 The Complete Talk</a></h3>
<p>Here's the full talk.ron file:</p>
<pre><code class="language-ron">(
    actors: [
        ( slug: &quot;bob&quot;, name: &quot;Bob&quot; ),
    ],
    script: [
        ( id: 1, action: Join, actors: [ &quot;bob&quot; ], next: Some(2) ),
        ( id: 2, text: Some(&quot;Hello!&quot;), actors: [ &quot;bob&quot; ], next: Some(3) ),
        ( id: 3, action: Choice, choices: Some([
            (text: &quot;Hi Bob&quot;, next: 5), 
            (text: &quot;I'm Alice's BF.&quot;, next: 4)
        ])),
        ( id: 4, action: Leave, actors: [ &quot;bob&quot; ] ),
        ( id: 5, text: Some(&quot;:)&quot;), actors: [ &quot;bob&quot; ], next: Some(2) ),
    ]
)
</code></pre>
<h4 id="351-loops"><a class="header" href="#351-loops">3.5.1 Loops</a></h4>
<p>If you want to loop back, just use the next field:</p>
<pre><code class="language-ron">script: [
    ( id: 1, action: Join, actors: [ &quot;bob&quot; ], next: Some(2) ),
    ( id: 2, text: Some(&quot;Hello!&quot;), actors: [ &quot;bob&quot; ], next: Some(3) ),
    ...
    ( id: 5, text: Some(&quot;:)&quot;), actors: [ &quot;bob&quot; ], next: Some(2) ),
]
</code></pre>
<h2 id="4-spawning-the-talk-in-your-game"><a class="header" href="#4-spawning-the-talk-in-your-game">4. Spawning the talk in your game</a></h2>
<p>Now that we have a talk, let's add it to our game. To load the asset:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let h: Handle&lt;TalkData&gt; = asset_server.load(&quot;hello.talk.ron&quot;);
<span class="boring">}</span></code></pre></pre>
<p>That creates a <code>TalkData</code> asset. We need to store that handle so we can retrieve the actual TalkData and use it to spawn the action entities in the world:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Resource)]
struct MyTalkHandle(Handle&lt;TalkData&gt;);

fn load_talks(mut commands: Commands, server: Res&lt;AssetServer&gt;) {
    let h: Handle&lt;TalkData&gt; = server.load(&quot;hello.talk.ron&quot;);
    commands.insert_resource(MyTalkHandle(h));
}
<span class="boring">}</span></code></pre></pre>
<p>Now that we have the system that loads the talk, we need to spawn it in the world. We can do that in another system:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn spawn_talk(
    mut commands: Commands,
    talks: Res&lt;Assets&lt;TalkData&gt;&gt;,
    talk_handle: Res&lt;MyTalkHandle&gt;,
) {
    let my_talk = talks.get(&amp;talk_handle.0).unwrap();
    let talk_builder = TalkBuilder::default().fill_with_talk_data(my_talk); // create a TalkBuilder with the TalkData
    commands.spawn_talk(talk_builder, ()); // spawn the graph with a commands extension
}
<span class="boring">}</span></code></pre></pre>
<p>Alright! Now we have just spawned a graph of entities where each action is an entity with their own components. The actions performed by actors are also connected to the actors entities (just Bob in our case). </p>
<p>The entire graph is a child of a main entity with the <code>Talk</code> component, you can use it to identify the graph in the world.</p>
<h2 id="5-displaying-the-talk"><a class="header" href="#5-displaying-the-talk">5. Displaying the talk</a></h2>
<p>The plugin doesn't provide any UI system right now, so you can use whatever you want to display the dialogue.
A dialogue graph sends you events everytime you move to a new node, so you can create small systems that listen
to the different events.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn print_text(mut text_events: EventReader&lt;TextNodeEvent&gt;) {
    for txt_ev in text_events.read() {
        let mut speaker = &quot;Narrator&quot;;
        if !txt_ev.actors.is_empty() {
            speaker = &amp;txt_ev.actors[0];
        }
        println!(&quot;{speaker}: {}&quot;, txt_ev.text);
    }
}

fn print_join(mut join_events: EventReader&lt;JoinNodeEvent&gt;) {
    for join_event in join_events.read() {
        println!(&quot;--- {:?} enters the scene.&quot;, join_event.actors);
    }
}

fn print_leave(mut leave_events: EventReader&lt;LeaveNodeEvent&gt;) {
    for leave_event in leave_events.read() {
        println!(&quot;--- {:?} exit the scene.&quot;, leave_event.actors);
    }
}

fn print_choice(mut choice_events: EventReader&lt;ChoiceNodeEvent&gt;) {
    for choice_event in choice_events.read() {
        println!(&quot;Choices:&quot;);
        for (i, choice) in choice_event.choices.iter().enumerate() {
            println!(&quot;{}: {}&quot;, i + 1, choice.text);
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The basics events are the <code>TextNodeEvent</code>, <code>JoinNodeEvent</code>, <code>LeaveNodeEvent</code> and <code>ChoiceNodeEvent</code>. They all have the <code>actors</code> field to quickly access the actor names. In case of no actors (empty vector) we're defaulting to &quot;Narrator&quot;.</p>
<h2 id="6-interacting-with-the-talk"><a class="header" href="#6-interacting-with-the-talk">6. Interacting with the talk</a></h2>
<p>We spawned and are listening to the talk events, but we can't interact with it to move forward (or pick a choice). </p>
<p>To do that, the plugin has another kind of events: the &quot;Request&quot; events that you can send. Here the 2 that we will use: <code>NextNodeRequest</code> and <code>ChooseNodeRequest</code>. They both need the entity with the <code>Talk</code> component you want to update, and for the <code>ChooseNodeRequest</code> you also need to provide the entity of the next action to go to.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Advance the talk when the space key is pressed and select choices with 1 and 2.
fn interact(
    input: Res&lt;Input&lt;KeyCode&gt;&gt;,
    mut next_action_events: EventWriter&lt;NextNodeRequest&gt;,
    mut choose_action_events: EventWriter&lt;ChooseNodeRequest&gt;,
    talks: Query&lt;Entity, With&lt;Talk&gt;&gt;,
    choices: Query&lt;&amp;ChoiceNode, With&lt;CurrentNode&gt;&gt;,
) {
    let talk_ent = talks.single();

    if input.just_pressed(KeyCode::Space) {
        next_action_events.send(NextNodeRequest::new(talk_ent));
    }

    // Note that you CAN have a TextNode component and a ChoiceNode component at the same time.
    // It would allow you to display some text beside the choices.
    if choices.iter().count() == 0 {
        return;
    }

    let choice_node = choices.single();

    if input.just_pressed(KeyCode::Key1) {
        choose_action_events.send(ChooseNodeRequest::new(talk_ent, choice_node.0[0].next));
    } else if input.just_pressed(KeyCode::Key2) {
        choose_action_events.send(ChooseNodeRequest::new(talk_ent, choice_node.0[1].next));
    }
}
<span class="boring">}</span></code></pre></pre>
<p>To grab the Talk entity for the events is pretty easy, just query for it.</p>
<p>For the ChooseNodeRequest event we need access to the possible choices if the current node has the <code>ChoiceNode</code> component. To grab them we can do a query on the special <code>CurrentNode</code> that is attached only to the current node entity in a graph (note that if you have multiple dialogue graphs you will have multiple <code>CurrentNode</code>s and you will have to filter them).</p>
<h2 id="thats-it"><a class="header" href="#thats-it">That's it!</a></h2>
<p>The tutorial was based on the <a href="https://github.com/giusdp/bevy_talks/blob/main/examples/full.rs">&quot;full&quot; example</a> code in the examples folder. Also checkout the other examples, in particular the <a href="https://github.com/giusdp/bevy_talks/blob/main/examples/ingame.rs">ingame</a> one where 2 dialogue graphs are spawned and set as children (actually the Talk parent entity) of 2 interactable entities.</p>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<p>The plugin is being developed slowly but steady. Many many things are still missing or being experimented with. Hopefully in the following years as Bevy will shape up to a 1.0 this plugin will be the best dialogue system for it. :)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-talks-with-talkbuilder"><a class="header" href="#creating-talks-with-talkbuilder">Creating Talks with TalkBuilder</a></h1>
<p>You can build dialogue graphs programmatically using the <code>TalkBuilder</code>. </p>
<blockquote>
<p>[â“˜] 
The <code>TalkBuilder</code> is also used under the hood to build the graphs from the asset files.</p>
</blockquote>
<p>If you need to generate procedurally dialogue graphs, or you just don't like the asset files, you can use this approach. Otherwise use the <code>talk.ron</code> files explained in the <a href="builder/../getting-started/index.html">Getting Started</a> chapter.</p>
<h3 id="simple-usage"><a class="header" href="#simple-usage">Simple Usage</a></h3>
<p>Depending on your needs, building a dialogue graph via code can be more or less verbose. 
A simple, linear, conversation such as:</p>
<pre><code class="language-mermaid">graph LR
    A((Start)) --&gt; B[Say]
    B --&gt; C[Say]
</code></pre>
<p>can be built with just a few lines of code:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let talk_builder = Talk::builder().say(&quot;Hello&quot;).say(&quot;World&quot;);
let talk_commands = commands.talks();
commands.spawn_talk(talk_builder);
<span class="boring">}</span></code></pre></pre>
<p>To actually spawn the entities with the relationships, you pass the <code>TalkBuilder</code> to the <code>Commands::spawn_talk</code> method, which will prepare a <code>Command</code> to be added to the command queue.</p>
<p>The command, when applied, will first spawn the main parent entity of the graph with the <code>Talk</code> component. Then add a start node with <code>StartNode</code> component (the entry point of the graph) and finally spawn entities for each <code>say</code>, <code>choose</code> etc.</p>
<p>Usually the builder will connect the entities linearly based on the concatenated methods, with the only exception being the <code>choose</code> method which is used for branching. In the example above you would have 3 entities each in a relationship with the next one (start -&gt; say -&gt; say), all children of the main <code>Talk</code> entity.</p>
<p>You can check out all the methods that the builder provides in the <a href="https://docs.rs/bevy_talks/latest/bevy_talks/builder/struct.TalkBuilder.html">API docs</a>.</p>
<h3 id="build-branching-conversations"><a class="header" href="#build-branching-conversations">Build Branching Conversations</a></h3>
<p>The simplest example would be a conversation with just 1 choice node:</p>
<pre><code class="language-mermaid">graph LR
    A((Start)) --&gt; B[Say]
    B --&gt; C[Choice]
    C --&gt; D[Say]
    C --&gt; E[Say]
</code></pre>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let talk_builder = Talk::builder();

talk_builder.say(&quot;How are you?&quot;)
    .choose(vec![
        (&quot;I'm fine&quot;, Talk::builder().say(&quot;I'm glad to hear that&quot;)), 
        (&quot;I'm not fine&quot;, Talk::builder().say(&quot;I'm sorry to hear that&quot;)), 
    ]);
<span class="boring">}</span></code></pre></pre>
<p>The <code>choose</code> method expects a vector of tuples. The first element is the text field of the choice (to be displayed) and the second is the branch of the conversation, which is another <code>TalkBuilder</code> instance.</p>
<h3 id="multiple-branches"><a class="header" href="#multiple-branches">Multiple Branches</a></h3>
<p>To make the example a bit more complex, let's say we have another choice in a branch:</p>
<pre><code class="language-mermaid">graph LR
    A((Start)) --&gt; B[Say]
    B --&gt; C[Choice]
    C --&gt; D[Say]
    C --&gt; E[Say]
    E --&gt; F[Choice]
    F --&gt; G[Say]
    F --&gt; H[Say]
</code></pre>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let talk_builder = Talk::builder();

let happy_branch = Talk::builder().say(&quot;I'm glad to hear that&quot;);
let sad_branch = Talk::builder()
    .say(&quot;Why?&quot;)
    .choose(vec![
        (&quot;Jk, I'm fine&quot;, Talk::builder().say(&quot;Aight&quot;)), 
        (&quot;I want an editor!&quot;, Talk::builder().say(&quot;Me too :(&quot;))
    ]);

talk_builder.say(&quot;How are you?&quot;)
    .choose(vec![(&quot;I'm fine&quot;, happy_branch), (&quot;I'm not fine&quot;, sad_branch)]);
<span class="boring">}</span></code></pre></pre>
<p>It's easy to keep branching but it can get quite verbose and hard to read. </p>
<p>It is recommended to use the asset files for more complex conversations, but this can be useful if you want to quickly give some lines of texts to an item, or an NPC, or you are generating the conversation procedurally.</p>
<h3 id="connecting-nodes-manually"><a class="header" href="#connecting-nodes-manually">Connecting Nodes Manually</a></h3>
<p>You can connect nodes manually with the <code>connect_to</code> method. But you will need to have the node to connect to. </p>
<p>If for some reason we need a loop like this:</p>
<pre><code class="language-mermaid">graph LR
    A((Start)) --&gt; B[Say]
    B --&gt; C[Say]
    C --&gt; B
</code></pre>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut talk_builder = Talk::builder().say(&quot;Hello&quot;);

// grab latest node
let node_a = talk_builder.last_node_id();

talk_builder ? talk_builder.say(&quot;World&quot;).connect_to(node_a);
<span class="boring">}</span></code></pre></pre>
<p>The <code>node</code> method returns an identifier of the node, and we can use it to do manual connections. 
Note you cannot create one node loops since currently self referential relationships are not supported.</p>
<p>You can also chain multiple <code>connect_to</code> calls to connect multiple nodes to the same node.</p>
<h3 id="branching-and-manual-connections"><a class="header" href="#branching-and-manual-connections">Branching and Manual Connections</a></h3>
<p>Suppose we want to build this conversation:</p>
<pre><code class="language-mermaid">graph LR
    A((Start)) --&gt; B[Say]
    B --&gt; C[Say]
    C --&gt; D[Choice]
    D --&gt; E[Say]
    D --&gt; F[Say]
    F --&gt; B
</code></pre>
<p>Situations like this are somewhat common in games. You are talking to an NPC where only one choice lets you continue 
and the others are just some flavour text or some extra lore. </p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut talk_builder = Talk::builder().say(&quot;Hello&quot;);

// grab latest node
let convo_start = talk_builder.last_node_id();

talk_builder = talk_builder
    .say(&quot;Hey&quot;)
    .choose(vec![
        (&quot;Good Choice&quot;, Talk::builder().say(&quot;End of the conversation&quot;)),
        (&quot;Wrong Choice&quot;, Talk::builder().say(&quot;Go Back&quot;).connect_to(convo_start))
    ]);
<span class="boring">}</span></code></pre></pre>
<h3 id="connecting-to-the-same-node"><a class="header" href="#connecting-to-the-same-node">Connecting To The Same Node</a></h3>
<p>Imagine you want to land on a node from multiple places like this:</p>
<pre><code class="language-mermaid">graph LR
    A((Start)) --&gt; B[Choice]
    B --&gt; C[Say]
    C --&gt; D[Choice]
    D --&gt; E[Say]
    D --&gt; F[Say]
    E --&gt; F
    B --&gt; F
</code></pre>
<p>You have an initial choice that can take the player to the end of the conversation, or go for some chat and then another choices which either goes to the end or passes by a talk node first.</p>
<p>You can think of that last talk node as its own branch that is pointed by multiple nodes. </p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let end_branch_builder = Talk::builder().say(&quot;The End&quot;); // Create the end immediately
let end_node_id = end_branch_builder.last_node_id(); // &lt;- grab the end node

// Create the good path
let good_branch = Talk::builder().say(&quot;something&quot;).choose(vec![
    (&quot;Bad Choice&quot;, Talk::builder().connect_to(end_node_id.clone())),
    (
        &quot;Another Good Choice&quot;, 
        Talk::builder().say(&quot;Before the end...&quot;).connect_to(end_node_id)
    ),
]);

let builder = Talk::builder().choose(vec![
    (&quot;Good Choice&quot;, good_branch),
    // NB the builder is passed here. If we never add it and keep using connect_to
    // the end node would never be created
    (&quot;Bad Choice&quot;, end_branch_builder) 
]);
<span class="boring">}</span></code></pre></pre>
<h3 id="adding-actors-to-the-mix"><a class="header" href="#adding-actors-to-the-mix">Adding Actors to the mix</a></h3>
<p>We saw the builder in action with just the <code>say</code> method, but we can also have actors say stuff. 
First we need to add the actors to the builder:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut talk_builder = Talk::builder()
    .add_actor(&quot;bob&quot;, &quot;Bob&quot;)
    .add_actor(&quot;alice&quot;, &quot;Alice&quot;);
<span class="boring">}</span></code></pre></pre>
<p>Then we can use the <code>actor_say</code> method (or <code>actors_say</code> for multiple actors at once):</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>talk_builder = talk_builder.actor_say(&quot;bob&quot;, &quot;Hello&quot;)
    .actor_say(&quot;alice&quot;, &quot;Hi Bob&quot;);
<span class="boring">}</span></code></pre></pre>
<p>The first argument is the actor slug. If the builder doesn't have an actor with that slug, it will panic when building. So always make sure to add the correct actors first. Also there is a <code>actors_say</code> method that takes a vector of actors slug.</p>
<p>Actors can also &quot;join&quot; or &quot;leave&quot; the conversation. For that there are the relative methods <code>join</code> and <code>leave</code>:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>talk_builder = talk_builder.add_actor(&quot;bob&quot;, &quot;Bob&quot;)
    .join(&quot;bob&quot;)
    .actor_say(&quot;bob&quot;, &quot;Folks, it do be me.&quot;);
<span class="boring">}</span></code></pre></pre>
<h3 id="node-event-emitters"><a class="header" href="#node-event-emitters">Node Event Emitters</a></h3>
<p>The dialogue graph emits events when a node is reached. The way it does that is by using the <code>NodeEventEmitter</code> trait for the node components that implement it. </p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Trait to implement on dialogue node components to make them emit an event when reached.
#[bevy_trait_query::queryable]
pub trait NodeEventEmitter {
    /// Creates an event to be emitted when a node is reached.
    fn make(&amp;self, actors: &amp;[Actor]) -&gt; Box&lt;dyn Reflect&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p>In case of <code>say</code>, <code>choose</code>, <code>join</code> and <code>leave</code> the builder will spawn an entity and add the <code>TextNode</code>, <code>ChoiceNode</code>, <code>JoinNode</code> and <code>LeaveNode</code> components respectively. Each of these components implement the <code>NodeEventEmitter</code> trait.</p>
<p>The idea is that you can create a <code>Component</code>, implement the trait so you can create an <code>Event</code> (optionally injecting the active actors) and then use that event to trigger some logic in your game.</p>
<p>You can check out the <a href="https://github.com/giusdp/bevy_talks/blob/main/examples/custom_node_event.rs"><code>custom_node_event</code></a> example to see how to implement custom events. You will see that there is also a macro to help you with that and that you need to register the component (and event) with the <code>app.register_node_event::&lt;C, T&gt;()</code>.</p>
<h3 id="custom-node-components"><a class="header" href="#custom-node-components">Custom Node Components</a></h3>
<p>Related to the previous section, you can also add any custom components to a node with the <code>with_component</code> method:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Component, Reflect, Default)]
#[reflect(Component)]
struct MyCustomComponent {
    pub some: bool,
}

talk_builder = Talk::builder().say(&quot;Hello&quot;).with_component(MyCustomComponent::default());
<span class="boring">}</span></code></pre></pre>
<p>This will add the component to the node entity, but remember to register the component type first with <code>app.register_type::&lt;MyCustomComponent&gt;();</code>.</p>
<p>Going one step further, you can do a completely customized node by creating one empty first and then adding components to it:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let builder = Talk::builder().empty_node().with_component(MyCustomComponent::default());
<span class="boring">}</span></code></pre></pre>
<p>You could create any kind of entity graph this way!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="mermaid.min.js"></script>
        <script src="mermaid-init.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
